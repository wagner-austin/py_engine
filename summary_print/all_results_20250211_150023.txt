
# FileName: config.py
# version: 1.4
# Summary: Global configuration including base resolution, FPS, font size, scale, default screen dimensions,
#          and universal theme settings. Provides a function to update screen dimensions and scale.
# Tags: config, global, theme, scaling

BASE_WIDTH = 800
BASE_HEIGHT = 600
FPS = 60
BASE_FONT_SIZE = 32

# Default values—these will be updated at runtime.
SCALE = 1.0
SCREEN_WIDTH = BASE_WIDTH
SCREEN_HEIGHT = BASE_HEIGHT

THEME = {
    "background_color": (0, 0, 0),             # Black background
    "title_color": (57, 255, 20),              # Neon green for title
    "button_normal_color": (200, 0, 200),      # Neon purple for buttons (unselected)
    "button_selected_color": (57, 255, 20),     # Neon green for selected buttons
    "highlight_color": (57, 255, 20),          # Neon green for highlight border
    "border_color": (57, 255, 20),             # Border color (neon green)
    "instruction_color": (255, 255, 255),      # White instructions text
    "font_color": (255, 255, 255)
}

def update_dimensions(width, height):
    """
    Updates the global screen dimensions and scale based on the new width and height.
    This centralizes all calculations so that any module importing config will have the correct values.
    """
    global SCREEN_WIDTH, SCREEN_HEIGHT, SCALE
    SCREEN_WIDTH = width
    SCREEN_HEIGHT = height
    SCALE = min(SCREEN_WIDTH / BASE_WIDTH, SCREEN_HEIGHT / BASE_HEIGHT)


# FileName: scene_manager.py
# version: 2.1
# Summary: Scene manager for handling scene transitions and centralized input handling.
#          Any KEYDOWN event for Q or Escape immediately returns to the main menu.
# Tags: scene management, modular, central input handling, on_enter, text input, mobile, desktop

import pygame

class SceneManager:
    def __init__(self):
        self.scenes = {}
        self.current_scene = None

    def add_scene(self, name, scene):
        self.scenes[name] = scene

    def set_scene(self, name):
        if name in self.scenes:
            self.current_scene = self.scenes[name]
            if hasattr(self.current_scene, "on_enter"):
                self.current_scene.on_enter()

    def handle_event(self, event):
        # Centralized input: Q or Escape returns to the main menu.
        if event.type == pygame.KEYDOWN and event.key in (pygame.K_ESCAPE, pygame.K_q):
            self.set_scene("menu")
            return  # Do not process further.
        if self.current_scene:
            self.current_scene.handle_event(event)

    def update(self):
        if self.current_scene:
            self.current_scene.update()

    def draw(self, screen):
        if self.current_scene:
            self.current_scene.draw(screen)


# FileName: base_scene.py
# version: 2.2
# Summary: Base scene class providing common functionality and input handling for all scenes.
#          Supports a layered system and clears the screen before drawing.
# Tags: scene, base, modular, input handling

import pygame
import config

class BaseScene:
    def __init__(self, name):
        self.name = name
        # List of layers (each must have a 'z' attribute and update/draw methods).
        self.layers = []

    def handle_event(self, event):
        # Common input: restart text input on mouse click.
        if event.type == pygame.MOUSEBUTTONDOWN:
            pygame.key.start_text_input()
        # Delegate scene-specific input.
        self.on_input(event)

    def on_input(self, event):
        """Override in subclasses for scene-specific input handling."""
        pass

    def update(self):
        # Update all layers.
        for layer in self.layers:
            if hasattr(layer, "update"):
                layer.update()

    def draw(self, screen):
        # Clear the screen using a scene-specific background if set, else use the universal background.
        bg_color = getattr(self, "background_color", config.THEME["background_color"])
        screen.fill(bg_color)
        # Draw layers sorted by their z-index.
        for layer in sorted(self.layers, key=lambda l: l.z):
            if hasattr(layer, "draw"):
                layer.draw(screen)

    def on_enter(self):
        """Called when the scene becomes active."""
        pygame.key.start_text_input()


# FileName: ui_manager.py
# version: 2.1
# Summary: Provides UI elements such as buttons with customizable styles.
#          Supports separate colors for normal and selected states.
# Tags: UI, button, modular, input handling, graphics

import pygame

class Button:
    def __init__(self, rect, label, callback, font,
                 normal_color=(200, 0, 200),
                 selected_color=(57, 255, 20),
                 background_color=None):
        self.rect = pygame.Rect(rect)
        self.label = label
        self.callback = callback
        self.font = font
        self.normal_color = normal_color
        self.selected_color = selected_color
        self.background_color = background_color  # Optional fill color.
        # Pre-render text surfaces for performance.
        self.text_surface_normal = self.font.render(self.label, True, self.normal_color)
        self.text_surface_selected = self.font.render(self.label, True, self.selected_color)

    def draw(self, screen, selected=False):
        if self.background_color:
            pygame.draw.rect(screen, self.background_color, self.rect)
        text_surface = self.text_surface_selected if selected else self.text_surface_normal
        text_rect = text_surface.get_rect(center=self.rect.center)
        screen.blit(text_surface, text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.callback()


# FileName: main.py
# version: 1.2.2
# Summary: Main entry point for the application. Initializes pygame, sets screen scaling
#          using config.update_dimensions (so all modules import the correct values), and manages scene transitions.
# Tags: main, initialization, scene management, modular, layered

import pygame
import sys
import config
from scene_manager import SceneManager
from scenes.menu_scene import MenuScene
from scenes.test_scene import TestScene

def main():
    pygame.init()
    info = pygame.display.Info()
    
    # Retrieve initial dimensions from display info.
    initial_width = info.current_w
    initial_height = info.current_h

    # Set the display mode.
    screen = pygame.display.set_mode((initial_width, initial_height))
    
    # Immediately update the global screen dimensions and scale using the actual drawing surface size.
    config.update_dimensions(*screen.get_size())
    
    pygame.display.set_caption("Retro Menu Demo")
    config.FONT = pygame.font.SysFont(None, int(config.BASE_FONT_SIZE * config.SCALE))
    clock = pygame.time.Clock()

    # Start text input for on-screen keyboards.
    pygame.key.start_text_input()

    scene_manager = SceneManager()
    # Create and register scenes.
    menu_scene = MenuScene(scene_manager, config.FONT)
    test_scene = TestScene(scene_manager, config.FONT)
    scene_manager.add_scene("menu", menu_scene)
    scene_manager.add_scene("test", test_scene)
    
    # Start with the main menu.
    scene_manager.set_scene("menu")
    
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            scene_manager.handle_event(event)
    
        scene_manager.update()
        scene_manager.draw(screen)
    
        pygame.display.flip()
        clock.tick(config.FPS)
    
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()


# FileName: art_assets.py
# version: 1.0
# Summary: Contains ASCII art assets used by the application. Modify these arrays to update the artwork.
# Tags: art, ascii, assets, retro

HEADER_ART = [
    "=== HEADER ART PLACEHOLDER ===",
    "You can replace this with your own artwork."
]

LOADING_ART = [
    "--- LOADING ART PLACEHOLDER ---",
    "You can replace this with your own artwork."
]

HOMESCREEN_ART = [
    "::: HOMESCREEN ART PLACEHOLDER :::",
    "You can replace this with your own artwork."
]

DECORATION = [
    "... DECORATION PLACEHOLDER ...",
    "You can replace this with your own artwork."
]

BANNER = [
    "~~~ BANNER PLACEHOLDER ~~~"
]

BORDERS = [
    "+++ BORDERS PLACEHOLDER +++"
]

STAR_ART = [
    "     .       +  ':.  .      *              '            *  '",
    "                  '::._                                      ",
    "                    '._)                 * +              ' ",
    "                          .              .        |         ",
    "           .      o.               +            - o -.      ",
    " o'          '    .    /  .         o             |         ",
    "    .  *   '          /                         +           ",
    "   .                 *          '                      .    ",
    "                 .             .             .  .           ",
    "   *         .   .       .                   | '.           ",
    "  +          '+                .           - o -            ",
    "          .                                . |              ",
    "            '  '     ..                   +  .  . +.        ",
    "  .                              |          .-.             ",
    " '                 .'  * '     - o -         ) )            ",
    " +        '   .                   |          '-´         '  ",
    "                       +      .'                   '.       ",
    " .           .           o      .       . .      .          ",
    "                       '       . +~~                       .",
]

BACKGROUND_ART = []

#


# FileName: art_layers.py
# version: 1.0
# Summary: Provides art layers for universal background and foreground art.
#          Includes a helper function to stretch ASCII art lines horizontally.
# Tags: layers, art, ascii, modular

import pygame
import math
import config
from art_assets import STAR_ART, BACKGROUND_ART

def stretch_line(line, font, target_width):
    """Inserts extra spaces between characters to stretch the line horizontally."""
    current_width = font.size(line)[0]
    if current_width >= target_width:
        return line
    gaps = len(line) - 1
    if gaps <= 0:
        return line
    space_width = font.size(" ")[0]
    extra_spaces = math.ceil((target_width - current_width) / (gaps * space_width))
    new_line = line[0]
    for char in line[1:]:
        new_line += " " * extra_spaces + char
    return new_line

class StarArtLayer:
    def __init__(self, font):
        self.z = 0
        self.font = font
        self.art = STAR_ART
        self.line_height = self.font.get_height()

    def update(self):
        pass

    def draw(self, screen):
        # Stretch horizontally using stretch_line and distribute vertically
        top_margin = int(20 * config.SCALE)
        bottom_margin = int(20 * config.SCALE)
        available_height = config.SCREEN_HEIGHT - top_margin - bottom_margin
        num_lines = len(self.art)
        spacing = available_height / (num_lines - 1) if num_lines > 1 else available_height
        for i, line in enumerate(self.art):
            stretched_line = stretch_line(line, self.font, config.SCREEN_WIDTH)
            y = top_margin + i * spacing
            text_surface = self.font.render(stretched_line, True, (150, 150, 150))
            text_rect = text_surface.get_rect(center=(config.SCREEN_WIDTH // 2, int(y)))
            screen.blit(text_surface, text_rect)

class BackGroundArtLayer:
    def __init__(self, font):
        self.z = 2
        self.font = font
        self.art = BACKGROUND_ART
        self.line_height = self.font.get_height()

    def update(self):
        pass

    def draw(self, screen):
        # Draw crocodile art centered horizontally in the lower half of the screen.
        y = int(config.SCREEN_HEIGHT * 0.5)
        for line in self.art:
            text_surface = self.font.render(line, True, (100, 255, 100))
            text_rect = text_surface.get_rect(center=(config.SCREEN_WIDTH // 2, y))
            screen.blit(text_surface, text_rect)
            y += self.line_height


# FileName: effect_layers.py
# version: 1.0
# Summary: Provides effect layers such as the rain effect.
# Tags: layers, effects, rain, modular

import pygame
import random
import config

class RainEffectLayer:
    def __init__(self):
        self.z = 1
        self.lines = []
        self.num_lines = 50
        self.speed = int(5 * config.SCALE)
        for _ in range(self.num_lines):
            x = random.uniform(0, config.SCREEN_WIDTH)
            y = random.uniform(0, config.SCREEN_HEIGHT)
            length = int(10 * config.SCALE)
            self.lines.append({"x": x, "y": y, "length": length})
    
    def update(self):
        for line in self.lines:
            line["y"] += self.speed
            if line["y"] > config.SCREEN_HEIGHT:
                line["y"] = -line["length"]
    
    def draw(self, screen):
        color = (100, 100, 255)
        for line in self.lines:
            start_pos = (int(line["x"]), int(line["y"]))
            end_pos = (int(line["x"]), int(line["y"] + line["length"]))
            pygame.draw.line(screen, color, start_pos, end_pos, 1)


# FileName: instruction_layer.py
# version: 1.0
# Summary: Provides the instruction layer that displays on-screen instructions.
# Tags: layers, instructions, UI, modular

import pygame
import config

class InstructionLayer:
    def __init__(self, font):
        self.z = 3
        self.font = font
        self.text = "Use W/S to navigate, Enter to select, Q/Esc to return."
        self.color = config.THEME["instruction_color"]

    def update(self):
        pass

    def draw(self, screen):
        text_surface = self.font.render(self.text, True, self.color)
        screen.blit(text_surface, (int(20 * config.SCALE), config.SCREEN_HEIGHT - int(40 * config.SCALE)))


# FileName: border_layer.py
# version: 1.1
# Summary: Provides the border layer that draws a border around the screen. The border is drawn fully inside
#          the screen bounds so that no edge is clipped.
# Tags: layers, border, UI, modular

import pygame
import config

class BorderLayer:
    def __init__(self):
        self.z = 5
        self.border_color = config.THEME["border_color"]
        self.thickness = int(4 * config.SCALE)
    
    def update(self):
        pass
    
    def draw(self, screen):
        # Draw the border inside the screen bounds using the full screen dimensions.
        pygame.draw.rect(screen, self.border_color,
                         (0, 0, config.SCREEN_WIDTH, config.SCREEN_HEIGHT), self.thickness)


# FileName: universal_layers.py
# version: 1.1
# Summary: Aggregates universal layers for scenes by importing individual layer modules.
#          Now returns persistent (singleton) layer instances so that effects like the rain do not reset on scene changes.
# Tags: layers, universal, modular, persistent
from art_layers import StarArtLayer, BackGroundArtLayer
from effect_layers import RainEffectLayer
from instruction_layer import InstructionLayer
from border_layer import BorderLayer

_universal_layers = None

def get_universal_layers(font):
    """
    Returns a persistent list of universal layer instances.
    This ensures that effects such as the rain (in RainEffectLayer) maintain their state
    across scene transitions.
    """
    global _universal_layers
    if _universal_layers is None:
        _universal_layers = [
            StarArtLayer(font),       # z=0: Star art background
            RainEffectLayer(),        # z=1: Rain effect
           BackGroundArtLayer(font),     # z=2: Background art foreground
            InstructionLayer(font),   # z=3: On-screen instructions
            BorderLayer()             # z=5: Border drawn on top
        ]
    return _universal_layers


# FileName: menu_layer.py
# version: 1.0
# Summary: Provides the interactive menu layer (title and buttons) for the main menu.
# Tags: layers, menu, UI, modular

import pygame
import config
from ui_manager import Button

class MenuLayer:
    def __init__(self, scene_manager, font, menu_items):
        self.z = 4
        self.scene_manager = scene_manager
        self.font = font
        self.menu_items = menu_items  # List of (label, scene_key) tuples.
        self.selected_index = 0
        self.last_nav_time = 0
        self.debounce_interval = 100  # milliseconds
        self.buttons = []
        self.create_buttons()
    
    def create_buttons(self):
        button_width = int(300 * config.SCALE)
        button_height = int(70 * config.SCALE)
        margin = int(30 * config.SCALE)
        start_y = int(150 * config.SCALE)
        x = (config.SCREEN_WIDTH - button_width) // 2
        self.buttons = []
        for i, (label, scene_key) in enumerate(self.menu_items):
            y = start_y + i * (button_height + margin)
            rect = (x, y, button_width, button_height)
            button = Button(
                rect,
                label,
                lambda sk=scene_key: self.scene_manager.set_scene(sk),
                self.font,
                normal_color=config.THEME["button_normal_color"],
                selected_color=config.THEME["button_selected_color"]
            )
            self.buttons.append(button)
    
    def update(self):
        pass
    
    def draw(self, screen):
        title_text = "MAIN MENU"
        title_surface = self.font.render(title_text, True, config.THEME["title_color"])
        title_x = (config.SCREEN_WIDTH - title_surface.get_width()) // 2
        screen.blit(title_surface, (title_x, int(40 * config.SCALE)))
        for i, button in enumerate(self.buttons):
            selected = (i == self.selected_index)
            button.draw(screen, selected)
            if selected:
                pygame.draw.rect(screen, config.THEME["highlight_color"], button.rect, 3)
    
    def on_input(self, event):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_nav_time < self.debounce_interval:
            return
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_w:
                self.selected_index = (self.selected_index - 1) % len(self.buttons)
                self.last_nav_time = current_time
            elif event.key == pygame.K_s:
                self.selected_index = (self.selected_index + 1) % len(self.buttons)
                self.last_nav_time = current_time
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self.buttons[self.selected_index].callback()
                self.last_nav_time = current_time
        elif event.type == pygame.TEXTINPUT:
            text = event.text.lower()
            if text == "w":
                self.selected_index = (self.selected_index - 1) % len(self.buttons)
                self.last_nav_time = current_time
            elif text == "s":
                self.selected_index = (self.selected_index + 1) % len(self.buttons)
                self.last_nav_time = current_time
            elif text in ("\r", "\n", " "):
                self.buttons[self.selected_index].callback()
                self.last_nav_time = current_time


# FileName: documentation.py
# version: 1.0
# Summary: Provides an overview of the project structure, describing the purpose of each file,
#          and instructions for adding new scenes, modifying the border, adding new layers, and
#          changing settings or implementing additional features.
# Tags: documentation, project guide, developer reference, modular, layers, scenes

"""
PROJECT DOCUMENTATION & DEVELOPER REFERENCE

Project Structure:
------------------

1. config.py
   - Purpose:
       Contains global configuration settings such as the base resolution (BASE_WIDTH, BASE_HEIGHT),
       FPS, BASE_FONT_SIZE, and universal theme settings in the THEME dictionary.
   - How to Change Settings:
       Modify values such as FPS, BASE_FONT_SIZE, or any color settings in THEME.
       Adjust scaling factors (config.SCALE) are calculated in main.py based on these values.

2. main.py
   - Purpose:
       The main entry point for the application. It initializes pygame, sets screen scaling,
       creates the SceneManager, loads scenes, and runs the main loop.
   - How to Add New Scenes:
       Import your new scene module and add your scene instance to the SceneManager with:
         scene_manager.add_scene("my_scene", my_scene_instance)
       Then call scene_manager.set_scene("my_scene") to switch to it.
   - Note:
       This file ties together all modules and starts the application.

3. scene_manager.py
   - Purpose:
       Manages scene transitions, updates, and drawing. It also centralizes input handling
       (e.g., pressing Q or Escape returns to the main menu).
   - How to Add/Modify Scenes:
       Use add_scene() to register new scenes and set_scene() to change the active scene.

4. base_scene.py
   - Purpose:
       Provides the BaseScene class that all scene classes should inherit from. It defines common
       methods for input handling, updating layers, and drawing layers in a defined order.
   - How to Extend:
       Create a new scene class that inherits from BaseScene and override on_input(), update(), and draw()
       as needed. Use the layers system to add or remove visual components.

5. ui_manager.py
   - Purpose:
       Contains UI elements such as the Button class, which is used for interactive elements.
   - How to Use:
       Create buttons by instantiating Button with a rectangle, label, callback, font, and optional colors.
       Use these buttons in your scene layers for interactive controls.

6. art_assets.py
   - Purpose:
       Contains ASCII art assets (e.g., STAR_ART, CROCODILE, etc.). These arrays can be updated to change the artwork.
   - How to Update:
       Modify the art arrays to include your desired artwork. These assets are referenced by the art layer modules.

7. art_layers.py
   - Purpose:
       Provides art-related layers such as StarArtLayer and CrocodileLayer. StarArtLayer renders the star art
       background, stretching it horizontally and vertically. CrocodileLayer renders crocodile ASCII art.
   - How to Modify:
       Change the rendering logic or the colors inside these classes. For example, adjust the stretching algorithm
       in stretch_line() or change the color passed to font.render().

8. effect_layers.py
   - Purpose:
       Provides effect layers such as RainEffectLayer, which animates falling rain.
   - How to Modify:
       Change parameters (like the number of rain lines, speed, or color) to alter the rain effect.

9. instruction_layer.py
   - Purpose:
       Displays on-screen instructions (e.g., which keys to press) using a fixed text string.
   - How to Modify:
       Change the instruction text or style (color, font, position) within this file.

10. menu_layer.py
    - Purpose:
        Provides the interactive menu layer. It displays the title and buttons, and handles input
        (using W/S to navigate and Enter/Space to select).
    - How to Modify:
        Update the menu_items list or change the appearance and behavior of the buttons.
        This is where you can adjust the menu’s interactive features.

11. border_layer.py
    - Purpose:
        Draws a border around the screen.
    - How to Modify:
        Change the border color by updating config.THEME["border_color"] in config.py or directly in BorderLayer.
        Adjust thickness by modifying the self.thickness value in BorderLayer.
        The border is drawn inside the screen bounds (width and height reduced by 1) so that the bottom edge remains visible.

12. universal_layers.py
    - Purpose:
        Aggregates universal layers by importing individual layer modules (from art_layers.py, effect_layers.py,
        instruction_layer.py, and border_layer.py) and returning them as a list via get_universal_layers(font).
    - How to Modify:
        To change the composition or order of universal layers, update the list returned by get_universal_layers().
        To add a new universal layer, create a new module for it and add its instance to this list.

13. scenes/menu_scene.py
    - Purpose:
        Implements the main menu scene using a layered system. It combines the universal layers with an interactive
        menu layer (MenuLayer).
    - How to Modify:
        Add or change menu items in the menu_items list. For further customization, modify or add additional layers.
        The scene’s input is forwarded to the highest z-index layer that implements an on_input() method.

14. scenes/test_scene.py
    - Purpose:
        A simple test scene to verify that scene switching and layered rendering work properly.
    - How to Use:
        Use this as a template for creating additional scenes. It combines the universal layers with a custom TestLayer.
    - How to Modify:
        Edit TestLayer to display your test content, or create new scene-specific layers.

Adding New Scenes:
------------------
1. Create a new file in the scenes/ directory (e.g., scenes/my_new_scene.py) that inherits from BaseScene.
2. Implement the on_input(), update(), and draw() methods as needed.
3. Optionally, create custom layers for unique effects or UI elements.
4. In main.py, import your new scene and register it with the SceneManager using:
       scene_manager.add_scene("my_new_scene", my_new_scene_instance)
5. Switch to your new scene with scene_manager.set_scene("my_new_scene").

Modifying the Border:
---------------------
- Open border_layer.py and change properties:
    • To change color, update self.border_color (or change config.THEME["border_color"] in config.py).
    • To change thickness, modify self.thickness.
- The border is drawn using pygame.draw.rect() with the rectangle defined as (0, 0, config.SCREEN_WIDTH - 1, config.SCREEN_HEIGHT - 1)
  to ensure the bottom line is visible.

Adding New Layers:
------------------
1. Create a new module (e.g., my_new_layer.py) that defines a layer class.
    • Your layer class should have a 'z' attribute, update(), and draw() methods.
2. If your layer requires input handling, implement an on_input() method.
3. Import your new layer in universal_layers.py (or in your scene file) and add an instance to the list of layers.
4. Your new layer will then be drawn (or updated) automatically in the order determined by its z-index.

Changing Settings:
------------------
- Edit config.py for any universal settings, such as screen dimensions, FPS, font size, or theme colors.
- These settings are used throughout the project to ensure consistency.

Implementing Additional Features:
----------------------------------
- Follow the existing file structure and create new modules for new features.
- Use the UI elements in ui_manager.py for interactive components.
- Update universal_layers.py to include any new layers you create.
- Document your changes in this file (documentation.py) so future developers have a clear understanding.

This file serves as a reference guide to help you navigate and extend the project. It’s recommended to update
this documentation as you add new features or modify the architecture.

To view this documentation from the command line, simply run:
    python documentation.py
"""

if __name__ == "__main__":
    print(__doc__)





# FileName: menu_scene.py
# version: 2.4
# Summary: Main menu scene built using a layered system with universal layers (imported from separate modules)
#          and an interactive menu layer.
# Tags: menu, scene, layers, retro, modular, UI

from base_scene import BaseScene
from universal_layers import get_universal_layers
from menu_layer import MenuLayer

class MenuScene(BaseScene):
    def __init__(self, scene_manager, font):
        super().__init__("Menu")
        self.scene_manager = scene_manager
        self.font = font
        # Define menu items as (label, scene_key) tuples.
        menu_items = [
            ("Test Scene", "test")
        ]
        # Combine universal layers with the interactive menu layer.
        self.layers = get_universal_layers(font) + [MenuLayer(scene_manager, font, menu_items)]
    
    def on_input(self, event):
        # Forward input events to the top-most layer that implements an on_input handler.
        for layer in sorted(self.layers, key=lambda l: l.z, reverse=True):
            if hasattr(layer, "on_input"):
                layer.on_input(event)
                break


# FileName: test_scene.py
# version: 1.1
# Summary: Test scene to confirm that the universal layered system and scene switching work.
#          Uses universal layers along with a custom TestLayer for scene-specific content.
# Tags: test, scene, layers, modular

import pygame
from base_scene import BaseScene
import config
from universal_layers import get_universal_layers

class TestScene(BaseScene):
    def __init__(self, scene_manager, font):
        super().__init__("Test Scene")
        self.scene_manager = scene_manager
        self.font = font
        # Combine universal layers with a TestLayer.
        self.layers = get_universal_layers(font) + [TestLayer(font)]

    def on_input(self, event):
        # Forward input events to the top-most layer that supports input.
        for layer in sorted(self.layers, key=lambda l: l.z, reverse=True):
            if hasattr(layer, "on_input"):
                layer.on_input(event)
                break

class TestLayer:
    def __init__(self, font):
        self.z = 6  # Drawn on top of universal layers.
        self.font = font
        self.angle = 0  # For simple animation

    def update(self):
        self.angle = (self.angle + 2) % 360

    def draw(self, screen):
        # Draw test scene text.
        text = "TEST SCENE"
        text_surface = self.font.render(text, True, (255, 255, 255))
        text_rect = text_surface.get_rect(center=(config.SCREEN_WIDTH // 2, config.SCREEN_HEIGHT // 2))
        screen.blit(text_surface, text_rect)

    def on_input(self, event):
        # (Optional) Test-specific input handling.
        pass


#!/usr/bin/env python3
# FileName: summary.py
# version 1.4
# Summary: A command-line tool to scan Python files in a project directory for:
#   - FileName
#   - version
#   - Summary
#   - Tags
#
# Tags: help, info, summary, tool
#
# Features:
#   - Automatic discovery of *.py files (except itself, if desired)
#   - Filtering by file(s), tags, or a search term (checks file name, FileName line,
#     version, summary, and tags)
#   - Optionally printing the full code for each matched file
#   - Saving summary data as JSON:
#      --save-json with no argument => automatically names file in ./summary_print/
#      --save-json myfile.json => saves with a custom name
#   - NEW: Saving all matched files’ code to a .txt file (with line breaks) via --save-code and --savecode 

import os
import re
import json
import sys
import argparse
from datetime import datetime
from typing import List, Dict

# Regex patterns for the 4 lines:
RE_FILEHEADER = re.compile(r'^#\s*FileName\s*:\s*(.*)$', re.IGNORECASE)
RE_VERSION    = re.compile(r'^#\s*version\s*:\s*(.*)$', re.IGNORECASE)
RE_SUMMARY    = re.compile(r'^#\s*Summary\s*:\s*(.*)$', re.IGNORECASE)
RE_TAGS       = re.compile(r'^#\s*Tags\s*:\s*(.*)$', re.IGNORECASE)


class CustomArgParser(argparse.ArgumentParser):
    """
    Subclass ArgumentParser so that when there's an error
    (e.g., an unrecognized argument), it prints the full
    help text instead of just a short usage message.
    Also overrides help to be more concise & colored.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Provide a custom usage line, remove default 'positional arguments' display
        self.usage = "\033[1;34mUsage:\033[0m summary.py [OPTIONS] [FILES...]"

    def error(self, message):
        # Print our custom help on error
        sys.stderr.write(f"\n\033[1;31mError:\033[0m {message}\n\n")
        self.print_help()
        sys.exit(2)

    def print_help(self):
        # Print a simpler, colored help message (override default).
        # We omit big details about "positional arguments," synonyms, etc.
        help_text = f"""
\033[1;34mUsage:\033[0m summary.py [OPTIONS] [FILES...]

\033[1;36mScan Python files for FileName, version, Summary, and Tags.\033[0m

\033[1;33mOptions:\033[0m
  \033[1;32m-r, --root\033[0m
    Root directory to search for .py files (default is current dir).

  \033[1;32m-f, --files\033[0m
    Specific .py files to summarize. Overrides auto-discovery.

  \033[1;32m-t, --tags\033[0m
    Filter results by these tag(s). Multiple tags => include if any match.

  \033[1;32m-s, --search\033[0m
    Case-insensitive search in OS filename, FileName header, version, summary, or tags.

  \033[1;32m-pc, --print-code\033[0m
    Print the full code for each matched file to console.

  \033[1;32m-sj, --save-json\033[0m  [optional filename or no argument]
    Save results to JSON file. No argument => auto-naming.

  \033[1;32m-sc, --save-code & --savecode\033[0m  [optional filename or no argument]
    Save all matched files' code to a .txt file, with a blank line separating each file.
    No argument => auto-naming.

  \033[1;32m-h, --help\033[0m
    Show this help message and exit.

Examples:
  summary.py --root . --tags engine --print-code
  summary.py -s 'animation' -pc -sc code_dump.txt
"""
        sys.stdout.write(help_text + "\n")


def gather_all_py_files(root_dir: str) -> List[str]:
    """
    Recursively gather all .py files under root_dir.
    """
    all_py = []
    for dirpath, _, filenames in os.walk(root_dir):
        for fname in filenames:
            if fname.endswith(".py"):
                full_path = os.path.join(dirpath, fname)
                all_py.append(full_path)
    return all_py


def parse_summaries_from_file(filepath: str) -> Dict:
    """
    Parse the file for:
        # FileName: ...
        # version: ...
        # Summary: ...
        # Tags: ...
    Returns a dict with:
       {
         "filename": os.path.basename(filepath),
         "fullpath": filepath,
         "header_filename": str or None,
         "version": str or None,
         "summary": str or None,
         "tags": [list of strings],
       }
    """
    header_filename = None
    version_str     = None
    summary_str     = None
    tags_list       = []

    try:
        with open(filepath, "r", encoding="utf-8") as f:
            for line in f:
                line_stripped = line.strip()

                # Check for each pattern
                match_fileheader = RE_FILEHEADER.match(line_stripped)
                if match_fileheader:
                    header_filename = match_fileheader.group(1).strip()
                    continue

                match_version = RE_VERSION.match(line_stripped)
                if match_version:
                    version_str = match_version.group(1).strip()
                    continue

                match_summary = RE_SUMMARY.match(line_stripped)
                if match_summary:
                    summary_str = match_summary.group(1).strip()
                    continue

                match_tags = RE_TAGS.match(line_stripped)
                if match_tags:
                    raw_tags = match_tags.group(1).strip()
                    tags_list = [
                        t.strip()
                        for t in re.split(r'[,\s]+', raw_tags)
                        if t.strip()
                    ]
    except (IOError, OSError):
        pass

    return {
        "filename": os.path.basename(filepath),
        "fullpath": filepath,
        "header_filename": header_filename,
        "version": version_str,
        "summary": summary_str,
        "tags": tags_list
    }


def main():
    parser = CustomArgParser(
        add_help=False,  # We'll add our custom -h/--help
        description="Scan Python files for FileName, version, Summary, and Tags."
    )

    # Add a simple custom help
    parser.add_argument(
        "-h", "--help",
        action="store_true",
        help=argparse.SUPPRESS
    )

    parser.add_argument(
        "-r", "--root",
        default=".",
        help="Root directory to search for .py files (default current dir)."
    )
    parser.add_argument(
        "-f", "--files",
        nargs="*",
        default=None,
        help="Specific .py files to summarize. This overrides auto-discovery."
    )
    parser.add_argument(
        "-t", "--tags",
        nargs="*",
        default=None,
        help="Filter results by these tag(s). Multiple tags => any match triggers inclusion."
    )
    parser.add_argument(
        "-s", "--search",
        default=None,
        help="Search term (case-insensitive) in OS filename, # FileName, version, summary, or tags."
    )
    parser.add_argument(
        "-pc", "--print-code",
        action="store_true",
        help="If specified, also print the full code for each matched file."
    )
    # Save JSON (auto or custom name)
    parser.add_argument(
        "-sj", "--save-json",
        nargs="?",
        const="AUTO",
        default=None,
        help="Save results as JSON to a file. If no argument => auto-naming."
    )
    # Save code to a .txt file (auto or custom name)
    parser.add_argument(
        "-sc", "--save-code", "--savecode",
        nargs="?",
        const="AUTO",
        default=None,
        help="Save full code of matched files to a .txt file. If no argument => auto-naming."
    )

    # Hidden positional argument(s), not shown in help
    parser.add_argument(
        "files_pos",
        nargs="*",
        help=argparse.SUPPRESS
    )

    args = parser.parse_args()

    # If user asked for help, show it and exit
    if args.help:
        parser.print_help()
        sys.exit(0)

    # Merge positional files with --files if any
    if args.files_pos:
        if args.files is not None:
            args.files.extend(args.files_pos)
        else:
            args.files = args.files_pos

    # 1) Determine which files to process
    if args.files:
        py_files = [os.path.abspath(f) for f in args.files]
    else:
        py_files = gather_all_py_files(os.path.abspath(args.root))

    # 2) Parse each file for summaries
    all_summaries = []
    for fpath in py_files:
        info = parse_summaries_from_file(fpath)
        all_summaries.append(info)

    # 3) Filter by tags if specified
    if args.tags:
        lower_tags = [t.lower() for t in args.tags]
        filtered = []
        for summ in all_summaries:
            file_tags_lower = [t.lower() for t in summ["tags"]]
            if any(t in file_tags_lower for t in lower_tags):
                filtered.append(summ)
        all_summaries = filtered

    # 4) Filter by search term (checks file name, FileName line, version, summary, and tags)
    if args.search:
        search_lower = args.search.lower()
        filtered = []
        for summ in all_summaries:
            text_to_search = summ["filename"].lower()
            if summ["header_filename"]:
                text_to_search += " " + summ["header_filename"].lower()
            if summ["version"]:
                text_to_search += " " + summ["version"].lower()
            if summ["summary"]:
                text_to_search += " " + summ["summary"].lower()
            if summ["tags"]:
                text_to_search += " " + " ".join(t.lower() for t in summ["tags"])
            if search_lower in text_to_search:
                filtered.append(summ)
        all_summaries = filtered

    # 5) Display results in console (with some color)
    for summ in all_summaries:
        print(f"\033[93m{'=' * 60}\033[0m")
        print(f"\033[92mFile:\033[0m {summ['filename']}  \033[94m(Path:\033[0m {summ['fullpath']}\033[94m)\033[0m")
        print(f"\033[92mFileName header:\033[0m {summ['header_filename'] or '[None found]'}")
        print(f"\033[92mVersion:\033[0m {summ['version'] or '[None found]'}")
        print(f"\033[92mSummary:\033[0m {summ['summary'] or '[None found]'}")
        if summ["tags"]:
            print(f"\033[92mTags:\033[0m {', '.join(summ['tags'])}")
        else:
            print("\033[92mTags:\033[0m [None found]")

        # 6) Print code if requested
        if args.print_code:
            print(f"\033[96m{'-' * 60}\033[0m")
            print("\033[95mFile Content:\033[0m")
            print(f"\033[96m{'-' * 60}\033[0m")
            try:
                with open(summ["fullpath"], "r", encoding="utf-8") as fc:
                    code_lines = fc.read()
                print(code_lines)
            except Exception as e:
                print(f"Error reading file content: {e}")

    # 7) If requested, save results to JSON
    #    (We do the "stype + date" naming if user didn't provide a filename)
    json_file_path = None
    if args.save_json is not None:
        if args.save_json == "AUTO":
            # Automatic filename
            if args.search:
                stype = f"search_{args.search}"
            elif args.tags:
                stype = "tags_" + "_".join(args.tags)
            elif args.files:
                stype = "files"
            else:
                stype = "all"
            short_dt = datetime.now().strftime("%Y%m%d_%H%M%S")
            os.makedirs("./summary_print", exist_ok=True)
            json_file_path = f"./summary_print/{stype}_results_{short_dt}.json"
        else:
            json_file_path = args.save_json

        try:
            with open(json_file_path, "w", encoding="utf-8") as outfile:
                json.dump(all_summaries, outfile, indent=2)
            print(f"\n\033[92mSaved summary data to JSON:\033[0m {json_file_path}")
        except Exception as e:
            print(f"Error saving JSON data: {e}")

    # 8) If requested, save the full code of matched files to a text file
    #    (We reuse the same "stype + date" pattern as JSON, just .txt)
    if args.save_code is not None:
        if args.save_code == "AUTO":
            # If we already auto-named for JSON, use the same base
            if json_file_path and args.save_json == "AUTO":
                # same base name as the JSON, but with .txt
                outfile_code_path = os.path.splitext(json_file_path)[0] + ".txt"
            else:
                # Automatic naming if JSON not used or user provided a custom JSON path
                if args.search:
                    stype = f"search_{args.search}"
                elif args.tags:
                    stype = "tags_" + "_".join(args.tags)
                elif args.files:
                    stype = "files"
                else:
                    stype = "all"
                short_dt = datetime.now().strftime("%Y%m%d_%H%M%S")
                os.makedirs("./summary_print", exist_ok=True)
                outfile_code_path = f"./summary_print/{stype}_results_{short_dt}.txt"
        else:
            outfile_code_path = args.save_code

        try:
            os.makedirs(os.path.dirname(outfile_code_path), exist_ok=True)
        except OSError:
            # Might happen if user gave just a filename without directory
            pass

        try:
            with open(outfile_code_path, "w", encoding="utf-8") as out_file:
                for idx, summ in enumerate(all_summaries):
                    # Attempt to read the file code
                    code_data = ""
                    try:
                        with open(summ["fullpath"], "r", encoding="utf-8") as fc:
                            code_data = fc.read()
                    except Exception as e:
                        code_data = f"Error reading file: {e}\n"

                    # Write a header, then the code, then a blank line
                    out_file.write("\n")
                    out_file.write(code_data)
                    out_file.write("\n\n")  # blank line between files

            print(f"\n\033[92mSaved code to:\033[0m {outfile_code_path}")
        except Exception as e:
            print(f"Error saving code to file: {e}")


if __name__ == "__main__":
    main()


